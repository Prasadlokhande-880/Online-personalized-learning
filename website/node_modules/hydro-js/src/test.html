<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tests</title>
    <script type="module">
      import { runTests } from "@web/test-runner-mocha";
      import { expect } from "@esm-bundle/chai";
      import {
        html,
        h,
        hydro,
        render,
        setGlobalSchedule,
        setReuseElements,
        reactive,
        unset,
        emit,
        watchEffect,
        observe,
        getValue,
        onRender,
        onCleanup,
        internals,
        ternary,
        setInsertDiffing,
        $,
        unobserve,
        setAsyncUpdate,
        setShouldSetReactivity,
        view,
      } from "../dist/library.js";

      runTests(async () => {
        describe("library", () => {
          setGlobalSchedule(false); // Simplifies testing
          const sleep = (time) =>
            new Promise((resolve) => setTimeout(resolve, time));

          describe("functions", () => {
            describe("h", () => {
              it("handles functions correctly", () => {
                expect(
                  h(() => h("p", null, ["Hello World"]), null, [])
                    .textContent === "Hello World"
                ).to.be.true;
              });

              it("returns a valid element", () => {
                const test = reactive("A");
                setTimeout(() => {
                  unset(test);
                });
                expect(h("div", null, [test]).localName === "div").to.be.true;
              });

              it("returns a valid element when it has children", () => {
                expect(
                  h("div", null, [h("p", null, ["test"])]).childNodes.length ===
                    1
                ).to.be.true;
              });

              it("handles documentFragment", () => {
                expect(
                  h(h, null, h("p", null, "hi"), h("p", null, "ho"))
                    .nodeType === 11
                ).to.be.true;
              });
            });

            describe("documentFragment", () => {
              it("render elem in fragment", () => {
                const fragment = html`<div>here</div>
                  <div>and here</div>`;
                render(fragment);
                const unmount = render(html`<p>a</p>`, fragment);
                let condition = document.body.childElementCount === 1;
                unmount();

                expect(condition && document.body.childElementCount === 0);
              });

              it("render fragment in fragment", () => {
                const fragment = html`<div>here</div>
                  <div>and here</div>`;
                render(fragment);
                const unmount = render(html`<p>a</p><p>b</b>`, fragment);
                let condition = document.body.childElementCount === 2;
                unmount();

                expect(condition && document.body.childElementCount === 0);
              });

              it("render fragment in elem", () => {
                const elem = html`<div>here</div>`;
                render(elem);
                const unmount = render(html`<p>a</p><p>b</b>`, elem);
                let condition = document.body.childElementCount === 2;
                unmount();

                expect(condition && document.body.childElementCount === 0);
              });

              it("render text in fragment", () => {
                const fragment = html`<div>here</div>
                  <div>and here</div>`;
                render(fragment);
                const unmount = render(html`text`, fragment);
                let condition = document.body.childElementCount === 0;
                unmount();

                expect(condition && document.body.childElementCount === 0);
              });

              it("render fragment in text", () => {
                const text = html`text`;
                render(text);
                const unmount = render(
                  html`<div>here</div>
                    <div>and here</div>`,
                  text
                );
                let condition = document.body.childElementCount === 2;
                unmount();

                expect(condition && document.body.childElementCount === 0);
              });

              it("render elem in fragment - setInsertDiffing", () => {
                setInsertDiffing(true);
                const fragment = html`<div>here</div>
                  <div>and here</div>`;
                render(fragment);
                const unmount = render(html`<p>a</p>`, fragment);
                let condition = document.body.childElementCount === 1;
                unmount();
                setInsertDiffing(false);
                expect(condition && document.body.childElementCount === 0);
              });

              it("render fragment in fragment - setInsertDiffing", () => {
                setInsertDiffing(true);
                const fragment = html`<div>here</div>
                  <div>and here</div>`;
                render(fragment);
                const unmount = render(html`<p>a</p><p>b</b>`, fragment);
                let condition = document.body.childElementCount === 2;
                unmount();
                setInsertDiffing(false);
                expect(condition && document.body.childElementCount === 0);
              });

              it("render fragment in elem - setInsertDiffing", () => {
                setInsertDiffing(true);
                const elem = html`<div>here</div>`;
                render(elem);
                const unmount = render(html`<p>a</p><p>b</b>`, elem);
                let condition = document.body.childElementCount === 2;
                unmount();
                setInsertDiffing(false);
                expect(condition && document.body.childElementCount === 0);
              });

              it("render text in fragment - setInsertDiffing", () => {
                setInsertDiffing(true);
                const fragment = html`<div>here</div>
                  <div>and here</div>`;
                render(fragment);
                const unmount = render(html`text`, fragment);
                let condition = document.body.childElementCount === 0;
                unmount();
                setInsertDiffing(false);
                expect(condition && document.body.childElementCount === 0);
              });

              it("render fragment in text - setInsertDiffing", () => {
                setInsertDiffing(true);
                const text = html`text`;
                render(text);
                const unmount = render(
                  html`<div>here</div>
                    <div>and here</div>`,
                  text
                );
                let condition = document.body.childElementCount === 2;
                unmount();
                setInsertDiffing(false);
                expect(condition && document.body.childElementCount === 0);
              });
            });

            describe("setShouldSetReactivity", () => {
              it("code coverage", () => {
                setShouldSetReactivity(true);
              });
            });

            describe("setReuseElements", () => {
              it("code coverage", () => {
                setReuseElements(true);
              });
            });

            describe("setGlobalSchedule", () => {
              it("sets asnycUpdate on hydro objects", () => {
                hydro.schedule = {};
                expect(hydro.schedule.asyncUpdate).to.be.false;
                setGlobalSchedule(true);
                expect(hydro.schedule.asyncUpdate).to.be.true;
                setGlobalSchedule(false);
                expect(hydro.schedule.asyncUpdate).to.be.false;
                hydro.schedule = null;
              });
            });

            describe("setAsyncUpdate", () => {
              it("sets asnycUpdate on reactive object", () => {
                const schedule = reactive({});
                setAsyncUpdate(schedule, false);
                setTimeout(unset, 0, schedule);
              });

              it("works chained", () => {
                const abc = reactive({ a: { b: 4 } });
                setAsyncUpdate(abc.a, false);
                setTimeout(unset, 0, abc);
              });
            });

            describe("html", () => {
              // https://html.spec.whatwg.org/
              [
                "a",
                "abbr",
                "address",
                "area",
                "article",
                "aside",
                "audio",
                "b",
                "base",
                "bdi",
                "bdo",
                "blockquote",
                "body",
                "br",
                "button",
                "canvas",
                "caption",
                "cite",
                "code",
                "col",
                "colgroup",
                "data",
                "datalist",
                "dd",
                "del",
                "details",
                "dfn",
                "dialog",
                "div",
                "dl",
                "dt",
                "em",
                "embed",
                "fieldset",
                "figcaption",
                "figure",
                "footer",
                "form",
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6",
                "head",
                "header",
                "hgroup",
                "hr",
                "html",
                "i",
                "iframe",
                "img",
                "input",
                "ins",
                "kbd",
                "label",
                "legend",
                "li",
                "link",
                "main",
                "map",
                "mark",
                "menu",
                "meta",
                "meter",
                "nav",
                "noscript",
                "object",
                "ol",
                "optgroup",
                "option",
                "output",
                "p",
                "picture",
                "pre",
                "progress",
                "q",
                "rp",
                "rt",
                "ruby",
                "s",
                "samp",
                "script",
                "search",
                "section",
                "select",
                "slot",
                "small",
                "source",
                "span",
                "strong",
                "style",
                "sub",
                "summary",
                "sup",
                "svg",
                "table",
                "tbody",
                "td",
                "template",
                "textarea",
                "tfoot",
                "th",
                "thead",
                "time",
                "title",
                "tr",
                "track",
                "u",
                "ul",
                "var",
                "video",
                "wbr",
                "custom-wc",
              ].forEach((tag) => {
                it(`is able to create element ${tag}`, () => {
                  const elem = html`<${tag} />`;
                  expect(elem.localName === tag).to.be.true;
                });
              });

              it("returns empty text node", () => {
                expect(
                  html`<input type="checkbox" required=${false} />`
                    .textContent === ""
                ).to.be.true;
              });

              it("handles a new html doc correctly", () => {
                const elem = html`<html>
                  <head></head>
                  <body>
                    a
                  </body>
                </html>`;
                expect(
                  elem.localName === "html" &&
                    !!elem.querySelector("head") &&
                    !!elem.querySelector("body")
                ).to.be.true;
              });

              it("returns empty text node", () => {
                expect(document.createTextNode("").isEqualNode(html``)).to.be
                  .true;
              });

              it("returns text node", () => {
                expect(
                  document.createTextNode("hello").isEqualNode(html`hello`)
                ).to.be.true;
              });

              it("returns document fragment", () => {
                const node = html`<div><p>hi</p></div>
                  <div><span>ho</span></div>`;
                expect(
                  node.nodeName !== "svg" &&
                    "getElementById" in node &&
                    node.childElementCount === 2
                ).to.be.true;
              });

              it("returns element", () => {
                const elem = html`<p>hello</p>`;
                expect(
                  elem.localName === "p" && elem.textContent.includes("hello")
                ).to.be.true;
              });

              it("variable input (node)", () => {
                const p = html`<p>hi</p>`;
                const elem = html`<div>${p}</div>`;
                expect(elem.contains(p) && elem.textContent.includes("hi")).to
                  .be.true;
              });

              it("variable input (primitive value)", () => {
                const test = "test";
                const elem = html`<div>${test}</div>`;
                expect(elem.textContent.includes(test)).to.be.true;
              });

              it("variable input (hydro)", () => {
                hydro.testValue = "test";
                const elem = html`<div>{{ testValue }}</div>`;
                setTimeout(() => {
                  hydro.testValue = null;
                });
                expect(elem.textContent.includes(hydro.testValue)).to.be.true;
              });

              it("variable input (reactive) - does not include undefined", () => {
                const data = reactive({});
                const elem = html`<div>${data.test}</div>`;
                setTimeout(unset, 0, data);
                expect(elem.textContent.includes(undefined)).to.be.false;
              });

              it("variable input (reactive)", () => {
                const test = reactive("test");
                const elem = html`<div>${test}</div>`;
                setTimeout(unset, 0, test);
                expect(elem.textContent.includes(getValue(test))).to.be.true;
              });

              it("variable input (eventListener)", () => {
                const onClick = (e) => (e.currentTarget.textContent = 1);
                const elem = html`<div onclick=${onClick}>0</div>`;

                elem.click();
                expect(elem.textContent.includes("1")).to.be.true;
              });

              it("variable input (array - normal)", () => {
                const arr = [42, "test"];
                const elem = html`<div>${arr}</div>`;
                expect(
                  elem.textContent.includes("42") &&
                    elem.textContent.includes("test")
                ).to.be.true;
              });

              it("variable input (function)", () => {
                const onClick = (e) =>
                  (e.currentTarget.textContent =
                    Number(e.currentTarget.textContent) + 1);
                const elem = html`<div onclick=${onClick}>0</div>`;

                elem.click();
                expect(elem.textContent.includes("1")).to.be.true;
              });

              it("variable input (eventListener )", () => {
                const onClick = {
                  event: (e) =>
                    (e.currentTarget.textContent =
                      Number(e.currentTarget.textContent) + 1),
                  options: {
                    once: true,
                  },
                };
                const elem = html`<div onclick=${onClick}>0</div>`;

                elem.click();

                elem.click();
                expect(elem.textContent.includes("1")).to.be.true;
              });

              it("variable input (array - node)", () => {
                const p = html`<p>test</p>`;
                const arr = [42, p];
                const elem = html`<div>${arr}</div>`;
                expect(
                  elem.textContent.includes("42") &&
                    elem.textContent.includes("test") &&
                    elem.contains(p)
                ).to.be.true;
              });

              it("variable input (object)", () => {
                const props = {
                  id: "test",
                  onclick: (e) =>
                    (e.currentTarget.textContent =
                      Number(e.currentTarget.textContent) + 1),
                  target: "_blank",
                };
                const elem = html`<a ${props}>0</a>`;

                elem.click();
                expect(
                  elem.id === "test" &&
                    elem.target === "_blank" &&
                    elem.textContent === "1"
                ).to.be.true;
              });

              it("variable input (object - with eventListenerObject)", () => {
                const props = {
                  id: "test",
                  onclick: {
                    event: (e) =>
                      (e.currentTarget.textContent =
                        Number(e.currentTarget.textContent) + 1),
                    options: {
                      once: true,
                    },
                  },
                  target: "_blank",
                };
                const elem = html`<a ${props}>0</a>`;

                elem.click();

                elem.click();
                expect(
                  elem.id === "test" &&
                    elem.target === "_blank" &&
                    elem.textContent === "1"
                ).to.be.true;
              });

              it("resolves deep reactive", () => {
                const person = reactive({
                  firstname: "Fabian",
                  lastname: "Krutsch",
                  char: { int: 777 },
                  items: [1, 2, 3],
                });

                const elem = html`
                  <p>
                    <span>His firstname is: </span
                    ><span>${person.firstname}</span><br />
                    <span>His int value is: </span
                    ><span>${person.char.int}</span><br />
                    <span>His first item is: </span
                    ><span>${person.items[0]}</span><br />
                  </p>
                `;
                const unmount = render(elem);

                person((curr) => {
                  curr.char.int = 123;
                  curr.items[0] = 0;
                });

                setTimeout(() => {
                  unmount();
                  unset(person);
                });

                expect(
                  document.body.innerText.includes("Fabian") &&
                    document.body.innerText.includes("123") &&
                    document.body.innerText.includes("0")
                ).to.be.true;
              });

              it("nested reactive", () => {
                const list = reactive([
                  { text: "Lorem", success: true },
                  { text: "ipsum", success: true },
                ]);
                const elem = html`
                  <div>
                    ${getValue(list).map((_, index) => {
                      return html`<p>${list[index].text}</p>`;
                    })}
                  </div>
                `;
                const unmount = render(elem);
                list((curr) => {
                  curr[0].text = "Changed";
                });
                const native = document.createElement("div");
                native.insertAdjacentHTML(
                  "beforeend",
                  `<p>Changed</p><p>ipsum</p>`
                );

                setTimeout(() => {
                  unset(list);
                  unmount();
                });
                expect(native.innerHTML.trim() === elem.innerHTML.trim()).to.be
                  .true;
              });

              it("removes {{..}}) from html attribute", () => {
                const attr = reactive({ id: "test" });
                const elem = html`<p ${attr}></p>`;
                const unmount = render(elem);

                setTimeout(() => {
                  unmount();
                  unset(attr);
                });

                expect(elem.id === "test" && !elem.hasAttribute("{{attr}}")).to
                  .be.true;
              });

              it("two-way attribute", () => {
                const text = reactive("text");
                const checked = reactive(true);
                const checkedRadio = reactive("A");
                const select = reactive("cat");
                const datetime = reactive("2018-06-08T00:00");

                const unmount = render(
                  html`
                    <div>
                      <input id="text" type="text" two-way=${text} />
                      <textarea two-way=${text}></textarea>

                      <label>
                        <input
                          id="checkbox1"
                          type="checkbox"
                          two-way=${checked}
                        />
                        John
                      </label>

                      <label>
                        <input
                          id="datetime"
                          type="datetime-local"
                          two-way=${datetime}
                          min="2018-06-07T00:00"
                          max="2020-06-14T00:00"
                        />
                      </label>

                      <label>
                        <input
                          id="radio1"
                          type="radio"
                          name="group"
                          value="A"
                          two-way=${checkedRadio}
                        />
                        A
                      </label>
                      <label>
                        <input
                          id="radio2"
                          type="radio"
                          name="group"
                          value="B"
                          two-way=${checkedRadio}
                        />
                        B
                      </label>

                      <label for="pet-select">Choose a pet:</label>
                      <select name="pets" id="pet-select" two-way=${select}>
                        <option value="">--Please choose an option--</option>
                        <option value="dog">Dog</option>
                        <option value="cat">Cat</option>
                        <option value="hamster">Hamster</option>
                        <option value="parrot">Parrot</option>
                        <option value="spider">Spider</option>
                        <option value="goldfish">Goldfish</option>
                      </select>
                    </div>
                  `
                );
                let cond =
                  $("#text").value === "text" &&
                  $("textarea").value === "text" &&
                  $("#checkbox1").checked &&
                  $("#radio1").checked &&
                  !$("#radio2").checked &&
                  $("select").value === "cat" &&
                  $("#datetime").value === "2018-06-08T00:00";

                // Code Coverage
                $("#radio1").dispatchEvent(new Event("change"));
                $("#checkbox1").click();

                text("haha");
                checked(false);
                checkedRadio("B");
                select("dog");
                datetime("2018-06-09T00:00");

                setTimeout(() => {
                  unmount();
                  unset(text);
                  unset(checked);
                  unset(checkedRadio);
                  unset(select);
                  unset(datetime);
                });

                expect(
                  cond &&
                    $("#text").value === "haha" &&
                    $("textarea").value === "haha" &&
                    !$("#checkbox1").checked &&
                    !$("#radio1").checked &&
                    $("#radio2").checked &&
                    $("select").value === "dog" &&
                    $("#datetime").value === "2018-06-09T00:00"
                ).to.be.true;
              });

              it("works with different events on one element", () => {
                let a, b, c;
                const elem = html`<p
                  ona=${() => (a = true)}
                  onb=${{ event: () => (b = true), options: {} }}
                  onc=${() => (c = true)}
                >
                  test
                </p>`;

                emit("a", {}, elem);
                emit("b", {}, elem);
                emit("c", {}, elem);

                expect(a).to.be.true;
                expect(b).to.be.true;
                expect(c).to.be.true;
              });

              it("stringifies object", () => {
                hydro.x = { a: 3 };
                const elem = html`<p>{{x}}</p>`;
                setTimeout(() => (hydro.x = null));
                expect(elem.textContent).to.equal('{"a":3}');
              });

              it("removes bind element", () => {
                hydro.y = { a: 3 };
                const elem = html`<p bind="{{y}}">asd</p>`;
                render(elem);
                hydro.y = null;
                expect(elem.isConnected).to.be.false;
              });

              it("removes bind element with multiple elements", () => {
                hydro.z = 4;
                const elem = html`<p bind="{{z}}">asd</p>`;
                const elem2 = html`<p bind="{{z}}">asd2</p>`;
                render(elem);
                render(elem2);
                hydro.z = null;
                expect(elem.isConnected).to.be.false;
                expect(elem2.isConnected).to.be.false;
              });

              it("super rare manipulation of DOM Element", () => {
                hydro.abc = { id: "jja", href: "cool" };
                const elem = html`<a id="{{abc.id}}" href="{{abc.href}}"
                  >asdad</a
                >`;
                elem.id = "{{abc.id}}";
                elem.href = "{{abc.href}}";
                html`<p>${elem}</p>`;
                setTimeout(() => (hydro.abc = null));
              });
            });

            describe("compare", () => {
              it("lifecycle hooks and text Nodes - false - length", () => {
                const renderFn1 = () => 2;
                const renderFn2 = () => 3;
                const cleanFn1 = () => 3;

                const elem1 = html`a`;
                const elem2 = html`a`;

                onRender(renderFn1, elem1);
                onRender(renderFn2, elem2);
                onCleanup(cleanFn1, elem1);

                expect(internals.compare(elem1, elem2) === false).to.be.true;
              });

              it("lifecycle hooks and text Nodes - false - string", () => {
                const renderFn1 = () => 2;
                const renderFn2 = () => 3;
                const cleanFn1 = () => 3;
                const cleanFn2 = () => 3;

                const elem1 = html`a`;
                const elem2 = html`a`;

                onRender(renderFn1, elem1);
                onRender(renderFn2, elem2);
                onCleanup(cleanFn1, elem1);
                onCleanup(cleanFn2, elem2);

                expect(internals.compare(elem1, elem2) === false).to.be.true;
              });

              it("returns false if child has different lifecycle hooks", () => {
                const subelem1 = html`hello`;
                onRender(() => 2, subelem1);
                const elem1 = html`<p>${subelem1}</p>`;

                const subelem2 = html`hello`;
                onRender(() => 3, subelem2);
                const elem2 = html`<p>${subelem2}</p>`;

                expect(internals.compare(elem1, elem2) === false).to.be.true;
              });

              it("returns false if child has different lifecycle hooks - onlyTextChildren", () => {
                const subelem1 = html`hello`;
                onRender(() => 2, subelem1);
                const elem1 = html`<p>${subelem1}</p>`;

                const subelem2 = html`hello`;
                onRender(() => 3, subelem2);
                const elem2 = html`<p>${subelem2}</p>`;

                expect(internals.compare(elem1, elem2, true) === false).to.be
                  .true;
              });

              it("lifecycle hooks and text Nodes - true", () => {
                const renderFn1 = () => 2;
                const renderFn2 = () => 2;
                const cleanFn1 = () => 3;
                const cleanFn2 = () => 3;

                const elem1 = html`a`;
                const elem2 = html`a`;

                onRender(renderFn1, elem1);
                onRender(renderFn2, elem2);
                onCleanup(cleanFn1, elem1);
                onCleanup(cleanFn2, elem2);

                expect(internals.compare(elem1, elem2) === true).to.be.true;
              });

              it("same functions return true", () => {
                const fn1 = () => 2;
                const fn2 = () => 2;
                const elem1 = html`<p onclick=${fn1}></p>`;
                const elem2 = html`<p onclick=${fn2}></p>`;
                expect(internals.compare(elem1, elem2) === true).to.be.true;
              });

              it("same lifecycle hooks return true", () => {
                const fn1 = () => 2;
                const fn2 = () => 2;

                const elem1 = html`<p>1</p>`;
                onRender(fn1, elem1);
                onCleanup(fn2, elem1);

                const elem2 = html`<p>1</p>`;
                onRender(fn1, elem2);
                onCleanup(fn2, elem2);

                expect(internals.compare(elem1, elem2) === true).to.be.true;
              });

              it("different function return false", () => {
                const fn1 = () => 2;
                const fn2 = () => 3;
                const elem1 = html`<p onclick=${fn1}></p>`;
                const elem2 = html`<p onclick=${fn2}></p>`;
                expect(internals.compare(elem1, elem2) === false).to.be.true;
              });

              it("different lifecycle hooks return false", () => {
                const fn1 = () => 2;
                const fn2 = () => 3;

                const elem1 = html`<p>1</p>`;
                onRender(fn1, elem1);
                onCleanup(fn2, elem1);

                const elem2 = html`<p>1</p>`;
                onRender(fn1, elem2);
                onCleanup(fn1, elem2);

                expect(internals.compare(elem1, elem2) === false).to.be.true;
              });
            });

            describe("render", () => {
              it("does diffing with documentFragment", () => {
                setInsertDiffing(true);
                const elem1 = html`it`;
                const elem2 = html`<p>hello</p>
                  <p>world</p>`;
                render(elem1);
                const unmount = render(elem2, elem1);
                setInsertDiffing(false);

                setTimeout(unmount);

                expect(
                  !document.body.textContent.includes("hi") &&
                    document.body.textContent.includes("hello") &&
                    document.body.textContent.includes("world")
                ).to.be.true;
              });

              it("do not reuseElements", () => {
                setReuseElements(false);
                const elem1 = html`a`;
                const elem2 = html`a`;
                render(elem1);
                const unmount = render(elem2, elem1);

                setTimeout(unmount);
                setReuseElements(true);
                expect(!elem1.isConnected && elem2.isConnected).to.be.true;
              });

              it("can render elements wrapped in reactive", async () => {
                const number = reactive(5);
                const elem = reactive(html`<p>${number}</p>`);
                const unmount = render(elem);
                const cond = getValue(elem).textContent.includes(
                  String(getValue(number))
                );

                setTimeout(() => number(6), 50);

                setTimeout(() => {
                  unset(number);
                  unset(elem);
                  unmount();
                }, 150);

                await sleep(100);
                expect(
                  cond &&
                    getValue(elem).textContent.includes(
                      String(getValue(number))
                    )
                ).to.be.true;
              });

              it("where does not exist - no render", () => {
                const elemCount = document.body.querySelectorAll("*").length;
                const unmount = render(html`<p>what</p>`, "#doesNotExist");

                setTimeout(unmount);
                expect(document.body.querySelectorAll("*").length === elemCount)
                  .to.be.true;
              });

              it("elem is DocumentFragment, no where", () => {
                const elem = html`<div id="first">1</div>
                  <div id="second">2</div>`;
                const unmount = render(elem);

                setTimeout(unmount);
                expect(
                  $("#first").textContent.includes("1") &&
                    $("#second").textContent.includes("2")
                ).to.be.true;
              });

              it("elem is svg, no where", () => {
                const elem = html`<svg height="100" width="100">
                  <circle
                    cx="50"
                    cy="50"
                    r="40"
                    stroke="black"
                    stroke-width="3"
                    fill="red"
                  />
                </svg>`;
                const unmount = render(elem);

                setTimeout(unmount);
                expect(
                  elem.isConnected && !!document.body.querySelector("circle")
                ).to.be.true;
              });

              it("elem is textNode, no where", () => {
                const elem = html`what`;
                const unmount = render(elem);

                setTimeout(unmount);
                expect(
                  elem.isConnected && document.body.textContent.includes("what")
                ).to.be.true;
              });

              it("elem is Element, no where", () => {
                const elem = html`<p id="whatWhere">what</p>`;
                const unmount = render(elem);

                setTimeout(unmount);
                expect(
                  elem.isConnected &&
                    $("#whatWhere").textContent.includes("what")
                ).to.be.true;
              });

              it("elem is DocumentFragment, with where", () => {
                document.body.insertAdjacentHTML(
                  "beforeend",
                  '<p id="hello">here</p>'
                );
                const elem = html`<div id="firstOne">1</div>
                  <div id="secondOne">2</div>`;
                const unmount = render(elem, "#hello");

                setTimeout(unmount);
                expect(
                  $("#firstOne").textContent.includes("1") &&
                    $("#secondOne").textContent.includes("2") &&
                    !document.body.querySelector("#hello")
                ).to.be.true;
              });

              it("elem is svg, with where", () => {
                document.body.insertAdjacentHTML(
                  "beforeend",
                  '<p id="hello2">here</p>'
                );
                const elem = html`<svg height="100" width="100">
                  <circle
                    cx="50"
                    cy="50"
                    r="40"
                    stroke="black"
                    stroke-width="3"
                    fill="red"
                  />
                </svg>`;
                const unmount = render(elem, "#hello2");

                setTimeout(unmount);
                expect(
                  elem.isConnected && !!document.body.querySelector("circle")
                ).to.be.true;
              });

              it("elem is textNode, with where", () => {
                document.body.insertAdjacentHTML(
                  "beforeend",
                  '<p id="hello3">here</p>'
                );
                const elem = html`what`;
                const unmount = render(elem, "#hello3");

                setTimeout(unmount);
                expect(
                  elem.isConnected &&
                    document.body.textContent.includes("what") &&
                    !document.body.querySelector("#hello3")
                ).to.be.true;
              });

              it("elem is Element, with where", () => {
                document.body.insertAdjacentHTML(
                  "beforeend",
                  '<p id="hello4">here</p>'
                );
                const elem = html`<p id="testThisWhat">what</p>`;
                const unmount = render(elem, "#hello4");

                setTimeout(unmount);
                expect(
                  elem.isConnected &&
                    $("#testThisWhat").textContent.includes("what") &&
                    !document.body.querySelector("#hello4")
                ).to.be.true;
              });

              it("replace an element will replace the event", () => {
                const click1 = (e) => (e.currentTarget.textContent = 1);
                const click2 = (e) => (e.currentTarget.textContent = 2);
                let elem = html` <div id="event" onclick=${click1}>0</div> `;

                render(elem);

                elem.click();
                let cond = elem.textContent.includes("1");

                elem = html` <div id="event" onclick=${click2}>0</div> `;
                const unmount = render(elem, "#event");

                elem.click();

                setTimeout(unmount);

                expect(cond && elem.textContent.includes("2")).to.be.true;
              });

              it("replacing elements will not stop their state", async () => {
                setInsertDiffing(true);
                const video1 = html`
                  <div id="video">
                    <p>Value: 0</p>
                    <video width="400" controls autoplay loop muted>
                      <source
                        src="https://www.w3schools.com/html/mov_bbb.mp4"
                        type="video/mp4"
                      />
                      <p>code coverage</p>
                    </video>
                  </div>
                `;
                const video2 = html`
                  <div id="video">
                    <p>Value: 1</p>
                    <video width="400" controls autoplay loop muted>
                      <source
                        src="https://www.w3schools.com/html/mov_bbb.mp4"
                        type="video/mp4"
                      />
                      <p>code coverage</p>
                    </video>
                  </div>
                `;
                // Video Test
                render(video1);

                await sleep(300);
                const time = $("video").currentTime;

                const unmount = render(video2, "#video");
                setInsertDiffing(false);

                await sleep(150);

                setTimeout(() => {
                  unmount();
                });

                expect(time <= $("video").currentTime).to.be.true;
              });

              it("calls lifecyle hooks on deep elements", () => {
                let subOnRender = false;
                let subOnCleanup = false;
                let elemOnRender = false;
                let elemOnCleanup = false;

                function SubElem() {
                  const subElem = html`<p></p>`;
                  onRender(() => (subOnRender = true), subElem);
                  onCleanup(() => (subOnCleanup = true), subElem);
                  return subElem;
                }
                function Elem() {
                  const elem = html`<p>${SubElem()}</p>`;
                  onRender(() => (elemOnRender = true), elem);
                  onCleanup(() => (elemOnCleanup = true), elem);
                  return elem;
                }
                const unmount = render(Elem());
                unmount();

                expect(
                  subOnRender && subOnCleanup && elemOnRender && elemOnCleanup
                ).to.be.true;
              });

              it("calls the correct lifecyle hooks when replacing elements", () => {
                let subOnRender = false;
                let subOnCleanup = false;
                let elemOnRender = false;
                let elemOnCleanup = false;

                const subElem = html`<p id="replace"></p>`;
                onRender(() => (subOnRender = true), subElem);
                onCleanup(() => (subOnCleanup = true), subElem);
                render(subElem);

                const elem = html`<p id="replace"></p>`;
                onRender(() => (elemOnRender = true), elem);
                onCleanup(() => (elemOnCleanup = true), elem);
                const unmount = render(elem, "#replace");

                setTimeout(unmount);
                expect(
                  subOnRender && subOnCleanup && elemOnRender && !elemOnCleanup
                ).to.be.true;
              });
            });

            describe("reactive", () => {
              it("primitive value", () => {
                const counter = reactive(0);
                const unmount = render(
                  html`
                    <div
                      id="reactClick"
                      onclick=${() => counter((prev) => prev + 1)}
                    >
                      ${counter}
                    </div>
                  `
                );

                $("#reactClick").click();

                setTimeout(() => {
                  unmount();
                  unset(counter);
                });

                expect($("#reactClick").textContent.includes("1")).to.be.true;
              });

              it("reactive (object)", () => {
                let obj1 = reactive({ a: { b: 5 } });
                let obj2 = reactive({ a: { b: 5 } });

                const unmount = render(
                  html`
                    <div>
                      <div
                        id="reactiveObj1"
                        onclick=${() =>
                          obj1((current) => {
                            current.a.b = 777;

                            return current;
                          })}
                      >
                        ${obj1.a.b}
                      </div>
                      <div
                        id="reactiveObj2"
                        onclick=${() =>
                          obj2((current) => {
                            current.a.b = 777;
                          })}
                      >
                        ${obj2.a.b}
                      </div>
                    </div>
                  `
                );

                $("#reactiveObj1").click();

                $("#reactiveObj2").click();
                setTimeout(() => {
                  unmount();
                  unset(obj1);
                  unset(obj2);
                });
                expect(
                  $("#reactiveObj1").textContent.includes("777") &&
                    $("#reactiveObj2").textContent.includes("777")
                ).to.be.true;
              });

              it("reactive (array)", () => {
                const arr1 = reactive([1, [2]]);
                const arr2 = reactive([3, [4]]);

                const unmount = render(
                  html`
                    <div
                      id="reactiveArr1"
                      onclick=${() =>
                        arr1((current) => {
                          current[0] += 1;

                          return current;
                        })}
                    >
                      ${arr1[0]}
                    </div>
                    <div
                      id="reactiveArr2"
                      onclick=${() =>
                        arr1((current) => {
                          current[1][0] += 1;

                          return current;
                        })}
                    >
                      ${arr1[1][0]}
                    </div>
                    <div
                      id="reactiveArr3"
                      onclick=${() =>
                        arr2((current) => {
                          current[0] += 1;
                        })}
                    >
                      ${arr2[0]}
                    </div>
                    <div
                      id="reactiveArr4"
                      onclick=${() =>
                        arr2((current) => {
                          current[1][0] += 1;
                        })}
                    >
                      ${arr2[1][0]}
                    </div>
                  `
                );

                $("#reactiveArr1").click();

                $("#reactiveArr2").click();

                $("#reactiveArr3").click();

                $("#reactiveArr4").click();

                setTimeout(() => {
                  unmount();
                  unset(arr1);
                  unset(arr2);
                });

                expect(
                  $("#reactiveArr1").textContent.includes("2") &&
                    $("#reactiveArr2").textContent.includes("3") &&
                    $("#reactiveArr3").textContent.includes("4") &&
                    $("#reactiveArr4").textContent.includes("5")
                ).to.be.true;
              });

              it("special logic for prev functions", () => {
                const a = reactive(undefined);
                const b = reactive(44);
                b(undefined);
                hydro.c = undefined;
                hydro.d = 44;
                hydro.d = undefined;
                const e = reactive(44);
                e((prev) => undefined);

                setTimeout(() => {
                  unset(a);
                  unset(b);
                  hydro.c = null;
                  hydro.d = null;
                  unset(e);
                });

                expect(
                  getValue(a) === undefined &&
                    getValue(b) === undefined &&
                    hydro.c === undefined &&
                    hydro.d === undefined,
                  getValue(e) === 44
                ).to.be.true;
              });
            });

            describe("watchEffect", () => {
              it("tracks and dependencies and re-runs the function (setter)", async () => {
                let watchCounter = 0;

                hydro.count1 = 0;
                hydro.count2 = 0;

                watchEffect(() => {
                  hydro.count1 = 2;
                  hydro.count2 = 2;
                  watchCounter++; // initial run + set + set (previous line)
                });

                hydro.count1 = 1;
                hydro.count2 = 1;

                setTimeout(() => {
                  hydro.count1 = null;
                  hydro.count2 = null;
                }, 200);

                await sleep(300);
                expect(watchCounter === 5).to.be.true;
              });

              it("tracks and dependencies and re-runs the function (getter)", () => {
                let watchCounter = 0;

                const count3 = reactive(0);
                const count4 = reactive(0);

                watchEffect(() => {
                  getValue(count3);
                  getValue(count4);
                  watchCounter++;
                });

                count3(1);
                count4(1);

                setTimeout(() => {
                  unset(count3);
                  unset(count4);
                });

                expect(watchCounter === 3).to.be.true;
              });

              it("tracks and dependencies and re-runs the function (stop)", () => {
                let watchCounter = 0;

                const count5 = reactive(0);

                const stop = watchEffect(() => {
                  getValue(count5);
                  watchCounter++;
                });

                stop();
                count5(1);
                setTimeout(() => {
                  unset(count5);
                });

                expect(watchCounter === 1).to.be.true;
              });
            });

            describe("observe", () => {
              it("observe hydro", () => {
                let test = 0;
                hydro.test = 0;

                hydro.observe("test", () => {
                  test++;
                });

                hydro.test++;

                setTimeout(() => {
                  hydro.test = null;
                });

                expect(test === 1).to.be.true;
              });

              it("observe reactive", () => {
                let result = 0;
                const test = reactive(0);

                observe(test, () => {
                  result++;
                });

                test(1);

                setTimeout(() => {
                  unobserve(test);
                  unset(test);
                });

                expect(result === 1).to.be.true;
              });

              it("observe primitive - function", () => {
                let result = 0;
                const test = reactive(0);

                observe(test, () => {
                  result++;
                });

                test((prev) => ++prev);

                setTimeout(() => {
                  unset(test);
                });

                expect(result === 1).to.be.true;
              });

              it("observe not working for primitive with function and no return", () => {
                let result = 0;
                const test = reactive(0);

                observe(test, () => {
                  result++;
                });

                test((prev) => {
                  prev = 1;
                });

                setTimeout(() => {
                  unset(test);
                });

                expect(result === 0).to.be.true;
              });

              it("observe object", () => {
                let result = 0;
                const test = reactive({ value: 0 });

                observe(test, () => {
                  result++;
                });

                test({ value: 1 });

                setTimeout(() => {
                  unset(test);
                });

                expect(result === 1).to.be.true;
              });
              it("observe object (return another) function", () => {
                let result = 0;
                const test = reactive({ value: 0 });

                observe(test, () => {
                  result++;
                });

                test(() => {
                  return { value: 1 };
                });

                setTimeout(() => {
                  unset(test);
                });

                expect(result === 1).to.be.true;
              });
              it("observe object (modified arg)", () => {
                let result = 0;
                const test = reactive({ value: 0 });

                observe(test.value, () => {
                  result++;
                });

                test((prev) => {
                  prev.value++;
                  return prev;
                });

                setTimeout(() => {
                  unset(test);
                });

                expect(result === 1).to.be.true;
              });

              it("observe object and modify arg plus no return", () => {
                let result = 0;
                const test = reactive({ value: 0 });

                observe(test.value, () => {
                  result++;
                });

                test((prev) => {
                  prev.value++;
                });

                setTimeout(() => {
                  unset(test);
                });

                expect(result === 1).to.be.true;
              });

              it("observe object and modify arg plus no return - new syntax", () => {
                let result = 0;
                const test = reactive({ value: 0 });

                observe(test.value, () => {
                  result++;
                });

                test.value.setter(5);

                setTimeout(() => {
                  unset(test);
                });

                expect(result === 1).to.be.true;
              });
            });

            describe("getValue", () => {
              it("primitive value", () => {
                const x = reactive(4);
                setTimeout(unset, 0, x);
                expect(getValue(x) === 4).to.be.true;
              });

              it("object", () => {
                const obj = { test: 4 };
                const x = reactive(obj);
                setTimeout(unset, 0, x);
                expect(getValue(x).test === obj.test).to.be.true;
              });

              it("array", () => {
                const arr = [4];
                const x = reactive(arr);
                setTimeout(unset, 0, x);
                expect(getValue(x)[0] === arr[0]).to.be.true;
              });
            });

            describe("unobserve", () => {
              it("works chained", () => {
                const abc = reactive({ a: { b: 4 } });
                unobserve(abc.a);
                setTimeout(unset, 0, abc);
              });
            });

            describe("unset", () => {
              it("works chained", () => {
                const abc = reactive({ a: { b: 4 } });
                unset(abc.a);
                expect(getValue(abc).a).to.not.be.ok;
                setTimeout(unset, 0, abc);
              });
            });

            describe("ternary", () => {
              it("condition as function", () => {
                const isTrue = reactive(true);

                let wasSetTrue = false;
                ternary(
                  () => getValue(isTrue),
                  () => (wasSetTrue = false),
                  () => (wasSetTrue = true),
                  isTrue
                );

                isTrue(false);

                setTimeout(unset, 0, isTrue);

                expect(wasSetTrue).to.be.true;
              });

              it("re-renders component", () => {
                const isToggleOn = reactive(false);
                let unmount;

                const handleClick = () => isToggleOn((prev) => !prev);

                unmount = render(
                  html`
                    <button id="reRender" onclick=${handleClick}>
                      ${ternary(isToggleOn, "ON", "OFF")}
                    </button>
                  `
                );

                $("#reRender").click();

                setTimeout(() => {
                  unmount();
                  unset(isToggleOn);
                });

                expect($("#reRender").textContent.includes("ON")).to.be.true;
              });

              it("re-renders component - function", () => {
                const isToggleOn = reactive(false);
                let unmount;

                const handleClick = () => isToggleOn((prev) => !prev);

                unmount = render(
                  html`
                    <button id="reRenderF" onclick=${handleClick}>
                      ${ternary(
                        isToggleOn,
                        () => "ON",
                        () => "OFF"
                      )}
                    </button>
                  `
                );

                $("#reRenderF").click();

                setTimeout(() => {
                  unmount();
                  unset(isToggleOn);
                });

                expect($("#reRenderF").textContent.includes("ON")).to.be.true;
              });
            });

            describe("onRender", () => {
              it("works with DocumentFragment", () => {
                const elem = html`<p>1</p>
                  <p>2</p>`;
                let count = 0;
                onRender(() => count++, elem, 1);
                const unmount = render(elem);

                setTimeout(unmount);
                expect(count).to.equal(1);
              });

              it("onRender", () => {
                let count = 0;
                const x = reactive(4);
                const elem = html` <p id="x">${x}</p> `;

                onRender(() => {
                  count++;
                }, elem);

                const unmount = render(elem);

                setTimeout(() => {
                  unset(x);
                  unmount();
                });

                expect(count === 1).to.be.true;
              });
            });

            describe("onCleanup", () => {
              it("onCleanup", () => {
                let count = 0;
                const x = reactive(4);
                const elem = html` <p id="x">${x}</p> `;

                onCleanup(() => {
                  count++;
                  unset(x);
                }, elem);

                const unmount = render(elem);
                unmount();

                expect(count === 1).to.be.true;
              });
            });

            describe("generateProxy", () => {
              it("add observer to observers", () => {
                hydro.x = 7;
                let firstObserver = false;
                let secondObserver = false;
                hydro.observe("x", () => {
                  firstObserver = true;
                });
                hydro.observe("x", () => {
                  secondObserver = true;
                });

                hydro.x = 777;

                setTimeout(() => {
                  hydro.x = null;
                });

                expect(firstObserver && secondObserver).to.be.true;
              });

              it("handles swapping data correctly", () => {
                hydro.data = [{ name: "Sebastian" }, { name: "Peter" }];

                const unmount = render(
                  html`<div>
                    ${hydro.data.map(
                      (_, i) =>
                        html`<p id="data-${i}">Name: {{data[${i}].name}}</p>`
                    )}
                  </div>`
                );

                [hydro.data[0], hydro.data[1]] = [hydro.data[1], hydro.data[0]];

                setTimeout(() => {
                  unmount();
                  hydro.data = null;
                });

                expect(
                  $("#data-0").textContent.includes("Peter") &&
                    $("#data-1").textContent.includes("Sebastian")
                ).to.be.true;
              });

              it("handles rejecting promise as expected", async () => {
                hydro.prom = Promise.reject(
                  "This is a Test for a rejected Promise"
                );
                await sleep(1);
                expect(hydro.prom).to.be.undefined;
              });

              it("intern properties", () => {
                hydro.obj = {};

                const isProxy = hydro.obj.isProxy === true;
                const asyncUpdate = hydro.obj.asyncUpdate === false;
                hydro.obj.asyncUpdate = true;
                const asyncWritable = hydro.obj.asyncUpdate === true;

                setTimeout(() => {
                  hydro.obj = null;
                });

                expect(isProxy && asyncUpdate && asyncWritable).to.be.true;
              });

              it("will not set falsy boolean attributes", () => {
                const checked = reactive(0);
                const elem = html`<input checked=${checked} />`;
                const unmount = render(elem);

                let cond = elem.hasAttribute("checked") === false;
                checked(1);
                cond = cond && elem.hasAttribute("checked");
                checked(false);
                cond = cond && elem.hasAttribute("checked") === false;

                setTimeout(() => {
                  unset(checked);
                  unmount();
                });

                expect(cond).to.be.true;
              });

              it("will not set falsy boolean attributes on obj", () => {
                const checked = reactive({ disabled: "" });
                const attr = reactive({ id: "boolAttr" });
                const elem = html`<input ${checked} ${attr} />`;
                const unmount = render(elem);

                setTimeout(() => {
                  unset(checked);
                  unset(attr);
                  unmount();
                });

                return expect(elem.hasAttribute("checked")).to.be.false;
              });

              it("updateDOM does not remove focus", () => {
                const count = reactive(0);
                const increment = () => count(1);

                const elem = html`
                  <div>
                    <span>${count}</span>
                    <button type="button" id="thisB" onclick=${increment}>
                      Increment
                    </button>
                  </div>
                `;

                const unmount = render(elem);

                // needed for automation
                $("#thisB").focus();

                $("#thisB").click();

                onCleanup(unset, elem, count);

                setTimeout(unmount);

                expect(document.activeElement === $("#thisB")).to.be.true;
              });

              it("using reactive variables in one variable - variable will be updated too", () => {
                const dynamicOne = reactive("classA");
                const dynamicTwo = reactive("classB");
                const classes = reactive(`${dynamicOne} ${dynamicTwo}`);
                const unmount = render(
                  html` <div id="classes" class=${classes}>test</div> `
                );

                let cond =
                  $("#classes").classList.contains(getValue(dynamicOne)) &&
                  $("#classes").classList.contains(getValue(dynamicTwo));

                dynamicOne("foo");
                dynamicTwo("bar");

                cond =
                  cond &&
                  !$("#classes").classList.contains("classA") &&
                  !$("#classes").classList.contains("classA") &&
                  $("#classes").classList.contains(getValue(dynamicOne)) &&
                  $("#classes").classList.contains(getValue(dynamicTwo));

                classes("peter pan");

                cond =
                  cond &&
                  !$("#classes").classList.contains(getValue(dynamicOne)) &&
                  !$("#classes").classList.contains(getValue(dynamicTwo)) &&
                  $("#classes").classList.contains("peter") &&
                  $("#classes").classList.contains("pan");

                setTimeout(() => {
                  unmount();
                  unset(classes);
                  unset(dynamicOne);
                  unset(dynamicTwo);
                });

                expect(cond).to.be.true;
              });

              it("swap operation (hydro)", () => {
                hydro.array = ["x", "y"];
                [hydro.array[0], hydro.array[1]] = [
                  hydro.array[1],
                  hydro.array[0],
                ];

                setTimeout(() => {
                  hydro.array = null;
                });

                expect(hydro.array[0] === "y").to.be.true;
              });

              it("swap operation (reactive)", () => {
                const array = reactive(["x", "y"]);

                array((arr) => {
                  [arr[0], arr[1]] = [arr[1], arr[0]];
                });

                setTimeout(unset, 0, array);

                expect(getValue(array)[0] === "y").to.be.true;
              });

              it("promise handling", async () => {
                const promise = reactive(
                  new Promise((resolve) => setTimeout(() => resolve(777), 200))
                );

                const unmount = render(html`<p id="async">
                  ${ternary(
                    promise,
                    () => html`<h2>${promise}</h2>`,
                    () => html`<h2>Loading...</h2>`
                  )}
                </p>`);

                await sleep(201);

                setTimeout(() => {
                  unmount();
                  unset(promise);
                }, 201);

                expect($("#async").textContent.includes("777")).to.be.true;
              });
            });

            describe("view", () => {
              it("creates a view that will handle add, delete and swap", async () => {
                let condition;

                const data = reactive([
                  { id: 4, label: "Red Onions" },
                  { id: 5, label: "Green Socks" },
                ]);
                const unmount = render(html`<ul></ul>`);
                view(
                  "ul",
                  data,
                  (item, i) =>
                    html`<li>
                      Reactive: ${data[i].id}, Non-reactive: ${item.label}
                    </li>`
                );

                await sleep(400);

                condition =
                  $("ul").textContent.includes("Red Onions") &&
                  $("ul").textContent.includes("Green Socks");

                data[0].setter((curr) => {
                  curr.id = 6;
                  curr.label = "Orange Hat";
                });

                condition =
                  condition &&
                  !$("ul").textContent.includes("Orange Hat") &&
                  $("ul").textContent.includes("6");

                data((curr) => {
                  [curr[0], curr[1]] = [curr[1], curr[0]];
                });

                condition = condition && getValue(data)[0].id === 5;

                setTimeout(() => {
                  unset(data);
                  unmount();
                }, 400);

                expect(condition).to.be.true;
              });

              it("creates a view that will handle add, delete and swap with (keyed)", async () => {
                setReuseElements(false);
                let condition;

                const data = reactive([
                  { id: 4, label: "Red Onions" },
                  { id: 5, label: "Green Socks" },
                ]);
                const unmount = render(html`<ul></ul>`);
                view(
                  "ul",
                  data,
                  (item, i) =>
                    html`<li>
                      Reactive: ${data[i].id}, Non-reactive: ${item.label}
                    </li>`
                );

                await sleep(300);

                condition =
                  $("ul").textContent.includes("Red Onions") &&
                  $("ul").textContent.includes("Green Socks");

                data[0].setter((curr) => {
                  curr.id = 6;
                  curr.label = "Orange Hat";
                });

                condition =
                  condition &&
                  !$("ul").textContent.includes("Orange Hat") &&
                  $("ul").textContent.includes("6");

                data((curr) => {
                  [curr[0], curr[1]] = [curr[1], curr[0]];
                });

                condition = condition && getValue(data)[0].id === 5;

                setTimeout(() => {
                  unset(data);
                  unmount();
                }, 300);

                setReuseElements(true);

                expect(condition).to.be.true;
              });
            });
          });

          describe("integration", () => {
            it("attributes are reactive", () => {
              const id = "firstId";
              const href = "https://www.google.com/";

              const props = reactive({ id, href });
              const elem = html` <a ${props}>link</a> `;

              const unmount = render(elem);

              props({ id: "secondId", href: "https://www.netlify.com/" });

              setTimeout(() => {
                unmount();
                unset(props);
              });

              const { id: id2, href: href2 } = getValue(props);
              expect(
                $(`#${id2}`) && $(`#${id2}`).getAttribute("href") === href2
              ).to.be.true;
            });

            it("event is reactive", () => {
              const props = reactive({
                onclick: (e) => (e.currentTarget.textContent = 1),
              });
              const elem = html` <p id="testREvent" ${props}>0</p> `;
              const unmount = render(elem);

              props({ onclick: (e) => (e.currentTarget.textContent = 2) });

              elem.click();

              setTimeout(() => {
                unmount();
                unset(props);
              });

              expect($("#testREvent").textContent === "2").to.be.true;
            });

            it("event is reactive with eventobject", () => {
              const props = reactive({
                onclick: (e) => (e.currentTarget.textContent = 1),
              });
              const elem = html` <p id="testREvent" ${props}>0</p> `;
              const unmount = render(elem);

              props({
                onclick: {
                  event: (e) => (e.currentTarget.textContent = 2),
                  options: {},
                },
                id: "testREvent2",
              });

              elem.click();

              setTimeout(() => {
                unmount();
                unset(props);
              });

              expect($("#testREvent2").textContent === "2").to.be.true;
            });

            it("eventObject is reactive", () => {
              const testEvent = reactive({
                event: (e) =>
                  (e.currentTarget.textContent =
                    Number(e.currentTarget.textContent) + 5),
                options: { once: true },
              });

              const unmount = render(
                html` <p id="testEvent" onclick=${testEvent}>0</p> `
              );

              $("#testEvent").click();

              $("#testEvent").click();

              let cond = $("#testEvent").textContent.includes("5");

              testEvent({
                event: (e) =>
                  (e.currentTarget.textContent =
                    Number(e.currentTarget.textContent) + 42),
                options: { once: true },
              });

              $("#testEvent").click();

              $("#testEvent").click();

              setTimeout(() => {
                unset(testEvent);
                unmount();
              });

              expect(cond && $("#testEvent").textContent.includes("47")).to.be
                .true;
            });

            it("eventObject can be replaced by normal fn", () => {
              const testEvent2 = reactive({
                event: (e) =>
                  (e.currentTarget.textContent =
                    Number(e.currentTarget.textContent) + 5),
                options: { once: true },
              });

              const unmount = render(
                html` <p id="testEvent2" onclick=${testEvent2}>0</p> `
              );

              //@ts-ignore
              $("#testEvent2").click();
              //@ts-ignore
              $("#testEvent2").click();

              let cond = $("#testEvent2").textContent.includes("5");

              testEvent2(
                (x) => (e) =>
                  (e.currentTarget.textContent =
                    Number(e.currentTarget.textContent) + 10)
              );

              //@ts-ignore
              $("#testEvent2").click();
              //@ts-ignore
              $("#testEvent2").click();

              setTimeout(() => {
                unset(testEvent2);
                unmount();
              });

              expect(cond && $("#testEvent2").textContent.includes("25")).to.be
                .true;
            });
          });

          describe("data handling check", () => {
            it("hydro is {}", async () => {
              await sleep(700);
              expect(JSON.stringify(hydro) === JSON.stringify({})).to.be.true;
            });

            it("hydro does not have any observers", async () => {
              await sleep(700);
              expect(hydro.getObservers().size === 0).to.be.true;
            });

            it("body has one DOM Element - unmount", async () => {
              await sleep(700);
              // 1 is default here
              expect(document.body.querySelectorAll("*").length).to.equal(1);
            });
          });

          describe("end tests", () => {
            it("diffs head against head", () => {
              let oldValue;
              let oldChildCount = 0;
              setTimeout(() => {
                oldValue = document.head.outerHTML;
                oldChildCount = document.head.childElementCount;
                setInsertDiffing(false);
                render(document.createElement("head"), document.head, false);
                expect(document.head.childElementCount === 0).to.be.true;
              }, 750);
              setTimeout(() => {
                setInsertDiffing(false);
                render(html`${oldValue}`, document.head, false);
                expect(oldChildCount === document.head.childElementCount).to.be
                  .true;
              }, 800);
            });

            it("diffs body against body", () => {
              let oldValue;
              let oldChildCount = 0;
              setTimeout(() => {
                oldValue = document.body.outerHTML;
                oldChildCount = document.body.childElementCount;
                setInsertDiffing(false);
                render(document.createElement("body"), document.body, false);
                expect(document.body.childElementCount === 0).to.be.true;
              }, 850);
              setTimeout(() => {
                setInsertDiffing(false);
                render(html`${oldValue}`, document.body, false);
                expect(oldChildCount === document.body.childElementCount).to.be
                  .true;
              }, 900);
            });

            it("diffs html against html", () => {
              let oldValue;
              let oldChildCount = 0;
              setTimeout(() => {
                oldValue = document.documentElement.outerHTML;
                oldChildCount = document.documentElement.childElementCount;
                setInsertDiffing(false);
                render(
                  document.createElement("html"),
                  document.documentElement,
                  false
                );
                expect(document.documentElement.childElementCount === 0).to.be
                  .true;
              }, 950);
              setTimeout(() => {
                setInsertDiffing(false);
                render(html`${oldValue}`, document.documentElement, false);
                expect(
                  oldChildCount === document.documentElement.childElementCount
                ).to.be.true;
              }, 1000);
            });

            it("diffs head against head - setInsertDiffing", () => {
              let oldValue;
              let oldChildCount = 0;
              setTimeout(() => {
                oldValue = document.head.outerHTML;
                oldChildCount = document.head.childElementCount;
                setInsertDiffing(true);
                render(document.createElement("head"), document.head, false);
                expect(document.head.childElementCount === 0).to.be.true;
              }, 1050);
              setTimeout(() => {
                setInsertDiffing(true);
                render(html`${oldValue}`, document.head, false);
                expect(oldChildCount === document.head.childElementCount).to.be
                  .true;
              }, 1100);
            });

            it("diffs body against body - setInsertDiffing", () => {
              let oldValue;
              let oldChildCount = 0;
              setTimeout(() => {
                oldValue = document.body.outerHTML;
                oldChildCount = document.body.childElementCount;
                setInsertDiffing(true);
                render(document.createElement("body"), document.body, false);
                expect(document.body.childElementCount === 0).to.be.true;
              }, 1150);
              setTimeout(() => {
                setInsertDiffing(true);
                render(html`${oldValue}`, document.body, false);
                expect(oldChildCount === document.body.childElementCount).to.be
                  .true;
              }, 1200);
            });

            it("diffs html against html - setInsertDiffing", () => {
              let oldValue;
              let oldChildCount = 0;
              setTimeout(() => {
                oldValue = document.documentElement.outerHTML;
                oldChildCount = document.documentElement.childElementCount;
                setInsertDiffing(true);
                render(
                  document.createElement("html"),
                  document.documentElement,
                  false
                );
                expect(document.documentElement.childElementCount === 0).to.be
                  .true;
              }, 1250);
              setTimeout(() => {
                setInsertDiffing(true);
                render(html`${oldValue}`, document.documentElement, false);
                expect(
                  oldChildCount === document.documentElement.childElementCount
                ).to.be.true;
              }, 1300);
            });
          });
        });
      });
    </script>
  </head>
  <body></body>
</html>
